#' TSS Heatmap Count Matrix
#'
#' @description
#' Generate count matrix to make TSS heatmap.
#'
#' @include TSRexplore.R
#' @include annotate.R
#'
#' @param annotated_data Annotated data.table
#' @param upstream Bases upstream of plot center
#' @param downstream Bases downstream of plot center
#'
#' @details
#' This function makes a count matrix for each gene or transcript with detected features
#'   relative to the annotated TSS.
#' Whether genes or transripts are used depends on the feature type chosen
#'   when annotating the TSSs with the 'annotate_features' function.
#' The count matrix is used for plotting a heatmap using the 'plot_heatmap' function.
#'
#' The region around the annotated TSS used for plotting is controlled by
#'   'upstream' and 'downstream', which should be positive integers.
#'
#' A set of arguments to control data structure for plotting are included.
#' 'use_normalized' will use the CPM normalized scores as opposed to raw read counts.
#' 'threshold' will define the minimum number of reads a TSS or TSR
#'  must have to be considered.
#' 'dominant' specifies whether only the dominant TSS or TSR is considered 
#'   from the 'mark_dominant' function.
#' For TSSs this can be either dominant per TSR or gene, and for TSRs
#'   it is just the dominant TSR per gene.
#' 'data_conditions' allows for the advanced filtering, ordering, and grouping
#'   of data.
#'
#' @return DataFrame of counts for each gene/transcript and position
#'
#' @examples
#' TSSs <- system.file("extdata", "S288C_TSSs.RDS", package="TSRexploreR")
#' TSSs <- readRDS(TSSs)
#' tsre_exp <- tsr_explorer(TSSs)
#' tsre_exp <- format_counts(tsre_exp, data_type="tss")
#' annotation <- system.file("extdata", "S288C_Annotation.gtf", package="TSRexploreR")
#' tsre_exp <- annotate_features(
#'   tsre_exp, annotation_data=annotation,
#'   data_type="tss", feature_type="transcript"
#' )
#' hm_mat <- tss_heatmap_matrix(tsre_exp)
#'
#' @seealso
#' \code{\link{annotate_features}} to annotate the TSSs or TSRs.
#' \code{\link{plot_heatmap}} to plot the heatmap.
#' \code{\link{tsr_heatmap_matrix}} to generate the TSR matrix data for plotting.

.tss_heatmap <- function(
  annotated_data,
  upstream=1000,
  downstream=1000
) {

  ## Create matrix.
  annotated_data <- annotated_data[, .(sample, score, distanceToTSS, feature)]

  # Cross-join so that all TSS distances are generated.
  tss_mat <- annotated_data[
    CJ(sample=sample, feature=feature, distanceToTSS=seq(-upstream, downstream, 1), unique=TRUE),
    , on=.(sample, feature, distanceToTSS)
  ]
  setnafill(tss_mat, col="score", fill=0)
  tss_mat[,
    distanceToTSS := factor(distanceToTSS, levels=seq(-upstream, downstream, 1))
  ]
  # Long to wide format for ComplexHeatmap matrix.
  tss_mat <- dcast(tss_mat, sample + feature ~ distanceToTSS, value.var="score")
  # Make factors for splitting plot later.
  sample_data <- unique(tss_mat[["sample"]])
  sample_data <- map(sample_data, ~rep(.x, length(seq(-upstream, downstream, 1))))
  sample_data <- purrr::reduce(sample_data, c)
  # Split samples and convert to matrix.
  tss_mat <- split(tss_mat, by="sample", keep.by=FALSE)
  tss_mat <- map(tss_mat, ~as.matrix(column_to_rownames(.x, "feature")))
  tss_mat <- purrr::reduce(tss_mat, cbind)

  return(list(mat=tss_mat, samps=sample_data))
}

#' Plot Heatmap
#'
#' @description
#' Plot heatmap from count matrix generated by tss_heatmap_matrix or tsr_heatmap_matrix
#'
#' @importFrom purrr keep
#'
#' @inheritParams common_params
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param ... Additional arguments passed to Heatmap
#'
#' @details
#' This plotting function generates a ggplot2 heatmap of TSS or TSR signal
#'   surrounding annotated TSSs of genes or transcripts.
#' Whether genes or transcripts are used depends on the feature type chosen
#'   when annotating the TSSs with the 'annotate_features' function. 
#'
#' @return ggplot2 object of TSS or TSR heatmap
#'
#' @examples
#' TSSs <- system.file("extdata", "S288C_TSSs.RDS", package="TSRexploreR")
#' TSSs <- readRDS(TSSs)
#' tsre_exp <- tsr_explorer(TSSs)
#' tsre_exp <- format_counts(tsre_exp, data_type="tss")
#' annotation <- system.file("extdata", "S288C_Annotation.gtf", package="TSRexploreR")
#' tsre_exp <- annotate_features(
#'   tsre_exp, annotation_data=annotation,
#'   data_type="tss", feature_type="transcript"
#' )
#' hm_mat <- tss_heatmap_matrix(tsre_exp)
#' plot_heatmap(hm_matrix)
#'
#' @seealso
#' \code{\link{annotate_features}} to annotate the TSSs or TSRs.
#' \code{\link{tss_heatmap_matrix}} to generate the TSS matrix data for plotting.
#' \code{\link{tsr_heatmap_matrix}} to generate the TSR matrix data for plotting.
#'
#' @rdname plot_heatmap-function
#' @export

plot_heatmap <- function(
  experiment,
  samples="all",
  data_type=c("tss", "tsr"),
  upstream=1000,
  downstream=1000,
  threshold=NULL,
  use_normalized=FALSE,
  dominant=FALSE,
  data_conditions=list(order_by="score"),
  ...
) {

  ## Check inputs.
  assert_that(is(experiment, "tsr_explorer"))
  assert_that(is.character(samples))
  assert_that(is.count(upstream))
  assert_that(is.count(downstream))
  assert_that(is.null(threshold) || (is.numeric(threshold) && threshold >= 0))
  assert_that(is.flag(use_normalized))
  assert_that(is.flag(dominant))
  if (all(!is.na(data_conditions)) && !is(data_conditions, "list")) {
    stop("data_conditions must be a list of values")
  }
  data_type <- match.arg(str_to_lower(data_type), c("tss", "tsr"))

  ## Get requested samples.
  annotated <- experiment %>%
    extract_counts(data_type, samples, use_normalized) %>%
    preliminary_filter(dominant, threshold)

  ## Remove antisense TSSs/TSRs.
  annotated <- map(annotated, ~.x[simple_annotations != "Antisense"])

  ## Rename feature ID.
  walk(annotated, function(x) {
    setnames(x,
      old=ifelse(
        experiment@settings$annotation[, feature_type] == "transcript",
        "transcriptId", "geneId"
      ),
      new="feature"
    )
  })
  annotated <- rbindlist(annotated, idcol="sample")

  ## Create the count matrix.
  count_mat <- switch(
    data_type,
    "tss"=.tss_heatmap(annotated, upstream, downstream),
    "tsr"=.tsr_heatmap(annotated, upstream, downstream)
  )

  ## Create heatmap.
  p <- count_mat[["mat"]] %>%
    {log2(. + 1)} %>%
    Heatmap(
      cluster_rows=FALSE, show_row_dend=FALSE,
      cluster_columns=FALSE, show_column_dend=FALSE,
      show_row_names=FALSE, show_column_names=FALSE,
      col=viridis::viridis(100),
      column_split=count_mat[["samps"]],
      name="log2 score",
      ...
    )

  return(p)

}

#' TSR Heatmap Count Matrix
#'
#' Generate count matrix to make TSR heatmap
#'
#' @include TSRexplore.R
#' @include annotate.R
#'
#' @param annotated_data Annotated data.table
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#'
#' @return Matrix of counts for each gene/transcript and position

.tsr_heatmap <- function(
  annotated_data,
  upstream=1000,
  downstream=1000
) {

  ## Prepare data for plotting.
  annotated_data[,
    c("startDist", "endDist", "tsr_id") := list(
      ifelse(strand == "+", start - geneStart, (geneEnd - end)),
      ifelse(strand == "+", end - geneStart, (geneEnd - start)),
      seq_len(.N)
    )
  ]
  ## Put TSR score for entire range of TSR.
  new_ranges <- annotated_data[,
    .(sample, feature, score,
    distanceToTSS=seq(as.numeric(startDist), as.numeric(endDist), 1)),
    by=tsr_id
  ]
  new_ranges[, tsr_id := NULL]
  new_ranges <- new_ranges[distanceToTSS >= -upstream & distanceToTSS <= downstream]

  ## Put score of 0 for ranges without TSR.
  new_ranges <- new_ranges[
    CJ(sample=sample, feature=feature, distanceToTSS=seq(-upstream, downstream, 1), unique=TRUE),
    , on=.(sample, feature, distanceToTSS)
  ]
  setnafill(new_ranges, cols="score", fill=0)

  ## Create matrix.
  new_ranges[, distanceToTSS := factor(distanceToTSS, levels=seq(-upstream, downstream, 1))]
  new_ranges <- dcast(new_ranges, sample + feature ~ distanceToTSS, value.var="score")

  # Make factors for splitting plot later.
  sample_data <- new_ranges[["sample"]] %>%
    unique %>%
    map(~rep(.x, length(seq(-upstream, downstream, 1)))) %>%
    purrr::reduce(c)

  tsr_mat <- new_ranges %>%
    split(by="sample", keep.by=FALSE) %>%
    map(~column_to_rownames(.x, "feature") %>% as.matrix) %>%
    purrr::reduce(cbind)

  return(list(mat=tsr_mat, samps=sample_data))
}
