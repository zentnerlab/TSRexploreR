#' TSS Heatmap Count Matrix
#'
#' @description
#' Generate count matrix to make TSS heatmap.
#'
#' @include TSRexplore.R
#' @include annotate.R
#'
#' @param annotated_data Annotated data.table
#' @param upstream Bases upstream of plot center
#' @param downstream Bases downstream of plot center
#' @param ... Arguments passed to geom_tile
#'
#' @details
#' This function makes a count matrix for each gene or transcript with detected features
#'   relative to the annotated TSS.
#' Whether genes or transripts are used depends on the feature type chosen
#'   when annotating the TSSs with the 'annotate_features' function.
#' The count matrix is used for plotting a heatmap using the 'plot_heatmap' function.
#'
#' The region around the annotated TSS used for plotting is controlled by
#'   'upstream' and 'downstream', which should be positive integers.
#'
#' A set of arguments to control data structure for plotting are included.
#' 'use_normalized' will use the CPM normalized scores as opposed to raw read counts.
#' 'threshold' will define the minimum number of reads a TSS or TSR
#'  must have to be considered.
#' 'dominant' specifies whether only the dominant TSS or TSR is considered 
#'   from the 'mark_dominant' function.
#' For TSSs this can be either dominant per TSR or gene, and for TSRs
#'   it is just the dominant TSR per gene.
#' 'data_conditions' allows for the advanced filtering, ordering, and grouping
#'   of data.
#'
#' @return DataFrame of counts for each gene/transcript and position
#'
#' @examples
#' TSSs <- system.file("extdata", "S288C_TSSs.RDS", package="TSRexploreR")
#' TSSs <- readRDS(TSSs)
#' tsre_exp <- tsr_explorer(TSSs)
#' tsre_exp <- format_counts(tsre_exp, data_type="tss")
#' annotation <- system.file("extdata", "S288C_Annotation.gtf", package="TSRexploreR")
#' tsre_exp <- annotate_features(
#'   tsre_exp, annotation_data=annotation,
#'   data_type="tss", feature_type="transcript"
#' )
#' hm_mat <- tss_heatmap_matrix(tsre_exp)
#'
#' @seealso
#' \code{\link{annotate_features}} to annotate the TSSs or TSRs.
#' \code{\link{plot_heatmap}} to plot the heatmap.
#' \code{\link{tsr_heatmap_matrix}} to generate the TSR matrix data for plotting.

.tss_heatmap <- function(
  annotated_data,
  upstream=1000,
  downstream=1000
) {

  ## Create matrix.
  annotated_data <- annotated_data[, .(sample, score, distanceToTSS, feature)]

  # Cross-join so that all TSS distances are generated.
  tss_mat <- annotated_data[
    CJ(sample=sample, feature=feature, distanceToTSS=seq(-upstream, downstream, 1), unique=TRUE),
    , on=.(sample, feature, distanceToTSS)
  ]
  setnafill(tss_mat, col="score", fill=0)
  tss_mat[,
    distanceToTSS := factor(distanceToTSS, levels=seq(-upstream, downstream, 1))
  ]
  
  return(tss_mat)
}

#' Plot Heatmap
#'
#' @description
#' Plot heatmap from count matrix generated by tss_heatmap_matrix or tsr_heatmap_matrix
#'
#' @importFrom purrr keep
#'
#' @inheritParams common_params
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param ... Additional arguments passed to Heatmap
#' @param max_value Truncate heatmap scale at this value.
#' @param low_color Color for minimum value.
#' @param high_color Color for maximum value.
#' @param log2_transform Log2 + 1 transform values for plotting.
#' @param x_axis_breaks The distance breaks to show values on the x-axis.
#'
#' @details
#' This plotting function generates a ggplot2 heatmap of TSS or TSR signal
#'   surrounding annotated TSSs of genes or transcripts.
#' Whether genes or transcripts are used depends on the feature type chosen
#'   when annotating the TSSs with the 'annotate_features' function. 
#'
#' @return ggplot2 object of TSS or TSR heatmap
#'
#' @examples
#' TSSs <- system.file("extdata", "S288C_TSSs.RDS", package="TSRexploreR")
#' TSSs <- readRDS(TSSs)
#' tsre_exp <- tsr_explorer(TSSs)
#' tsre_exp <- format_counts(tsre_exp, data_type="tss")
#' annotation <- system.file("extdata", "S288C_Annotation.gtf", package="TSRexploreR")
#' tsre_exp <- annotate_features(
#'   tsre_exp, annotation_data=annotation,
#'   data_type="tss", feature_type="transcript"
#' )
#' hm_mat <- tss_heatmap_matrix(tsre_exp)
#' plot_heatmap(hm_matrix)
#'
#' @seealso
#' \code{\link{annotate_features}} to annotate the TSSs or TSRs.
#' \code{\link{tss_heatmap_matrix}} to generate the TSS matrix data for plotting.
#' \code{\link{tsr_heatmap_matrix}} to generate the TSR matrix data for plotting.
#'
#' @rdname plot_heatmap-function
#' @export

plot_heatmap <- function(
  experiment,
  samples="all",
  data_type=c("tss", "tsr"),
  upstream=1000,
  downstream=1000,
  threshold=NULL,
  use_normalized=FALSE,
  dominant=FALSE,
  data_conditions=conditions(
    data_ordering=ordering(desc(score), .aggr_fun=sum)
  ),
  rasterize=FALSE,
  raster_dpi=150,
  max_value=NULL,
  low_color="white",
  high_color="blue",
  log2_transform=TRUE,
  x_axis_breaks=100,
  ...
) {

  ## Check inputs.
  assert_that(is(experiment, "tsr_explorer"))
  assert_that(is.character(samples))
  assert_that(is.count(upstream))
  assert_that(is.count(downstream))
  assert_that(is.null(threshold) || (is.numeric(threshold) && threshold >= 0))
  assert_that(is.flag(use_normalized))
  assert_that(is.flag(dominant))
  if (all(!is.na(data_conditions)) && !is(data_conditions, "list")) {
    stop("data_conditions must be a list of values")
  }
  data_type <- match.arg(str_to_lower(data_type), c("tss", "tsr"))
  assert_that(is.flag(rasterize))
  assert_that(is.count(raster_dpi))
  assert_that(
    is.null(max_value) ||
    (is.numeric(max_value) && max_value > 0)
  )
  assert_that(is.character(low_color))
  assert_that(is.character(high_color))
  assert_that(is.flag(log2_transform))

  ## Get requested samples.
  annotated <- experiment %>%
    extract_counts(data_type, samples, use_normalized) %>%
    preliminary_filter(dominant, threshold)

  ## Remove antisense TSSs/TSRs.
  annotated <- map(annotated, ~.x[simple_annotations != "Antisense"])

  ## Rename feature ID.
  walk(annotated, function(x) {
    setnames(x,
      old=ifelse(
        experiment@settings$annotation[, feature_type] == "transcript",
        "transcriptId", "geneId"
      ),
      new="feature"
    )
  })
  annotated <- rbindlist(annotated, idcol="sample")

  ## Create the count matrix.
  count_mat <- switch(
    data_type,
    "tss"=.tss_heatmap(annotated, upstream, downstream),
    "tsr"=.tsr_heatmap(annotated, upstream, downstream)
  )

  ## Log2 + 1 transform data if set.
  count_mat[, score := log2(score + 1)]

  ## Set sample order if required.
  if (!all(samples == "all")) {
    count_mat[, sample := factor(sample, levels=samples)]
  }

  ## Create heatmap.
  p <- ggplot(count_mat, aes(x=.data$distanceToTSS, y=.data$feature))

  # Apply rasterization if required.
  if (rasterize) {
    p <- p + rasterize(
      geom_tile(aes(fill=.data$score, color=.data$score), ...),
      dpi=raster_dpi
    )
  } else {
    p <- p + geom_tile(aes(fill=.data$score, color=.data$score), ...)
  }

  p <- p +
    geom_vline(xintercept=upstream, color="black", linetype="dashed", size=0.1) +
    scale_x_discrete(
      breaks=seq(-upstream, downstream, 1) %>% keep(~ (./x_axis_breaks) %% 1 == 0),
      labels=seq(-upstream, downstream, 1) %>% keep(~ (./x_axis_breaks) %% 1 == 0)
    )

  # Truncate scale if max_value is set.
  if (!is.null(max_value)) {
    p <- p +
      scale_fill_continuous(
        limits=c(0, max_value),
        breaks=seq(0, max_value, 1),
        labels=c(seq(0, max_value - 1, 1), paste0(">=", max_value)),
        name="Log2(Score)",
        low=low_color,
        high=high_color
      ) +
      scale_color_continuous(
        limits=c(0, max_value),
        breaks=seq(0, max_value, 1),
        labels=c(seq(0, max_value - 1, 1), paste0(">=", max_value)),
        name="Log2(Score)",
        low=low_color,
        high=high_color
      )
  } else {
    p <- p +
      scale_fill_continuous(
        name="Log2(Score)",
        low=low_color,
        high=high_color
      ) +
      scale_color_continuous(
        name="Log2(Score)",
        low=low_color,
        high=high_color
      )
  }

  p <- p +
    theme(
      axis.text.x=element_text(angle=45, hjust=1),
      panel.spacing=unit(1.5, "lines"),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank(),
      panel.grid=element_blank(),
      panel.background=element_rect(fill="white", color="white")
    ) +
    labs(x="Position", y="Feature")

  p <- p + facet_wrap(sample ~ ., scales="free")

  return(p)

}

#' TSR Heatmap Count Matrix
#'
#' Generate count matrix to make TSR heatmap
#'
#' @include TSRexplore.R
#' @include annotate.R
#'
#' @param annotated_data Annotated data.table
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#'
#' @return Matrix of counts for each gene/transcript and position

.tsr_heatmap <- function(
  annotated_data,
  upstream=1000,
  downstream=1000
) {

  ## Prepare data for plotting.
  annotated_data[,
    c("startDist", "endDist", "tsr_id") := list(
      ifelse(strand == "+", start - geneStart, (geneEnd - end)),
      ifelse(strand == "+", end - geneStart, (geneEnd - start)),
      seq_len(.N)
    )
  ]
  ## Put TSR score for entire range of TSR.
  new_ranges <- annotated_data[,
    .(sample, feature, score,
    distanceToTSS=seq(as.numeric(startDist), as.numeric(endDist), 1)),
    by=tsr_id
  ]
  new_ranges[, tsr_id := NULL]
  new_ranges <- new_ranges[distanceToTSS >= -upstream & distanceToTSS <= downstream]

  ## Put score of 0 for ranges without TSR.
  new_ranges <- new_ranges[
    CJ(sample=sample, feature=feature, distanceToTSS=seq(-upstream, downstream, 1), unique=TRUE),
    , on=.(sample, feature, distanceToTSS)
  ]
  setnafill(new_ranges, cols="score", fill=0)
  new_ranges[, distanceToTSS := factor(distanceToTSS, levels=seq(-upstream, downstream, 1))]

  return(new_ranges)
}
