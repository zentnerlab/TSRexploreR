% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_conditionals.R
\name{group_data}
\alias{group_data}
\title{Data Conditionals}
\usage{
group_data(
  signal_data,
  filters = NA,
  order_by = NA,
  order_direction = "descending",
  order_samples = NA,
  order_group = NA,
  quantile_by = NA,
  n_quantiles = NA,
  quantile_samples = NA,
  quantile_group = NA,
  quantile_direction = "descending",
  grouping = NA
)
}
\arguments{
\item{signal_data}{TSS or TSR data.}

\item{filters}{Logical string to subset/filter data by.}

\item{order_by}{Metric to order data by.}

\item{order_direction}{Whether the values should be ordered in
'ascending' or 'descending' order.}

\item{order_samples}{Names of samples to order by.}

\item{order_group}{Features will be aggregated by this group before ordering.}

\item{quantile_by}{Continuous metric for calculating quantiles.}

\item{n_quantiles}{Number of quantiles to calculate for continuous metric.}

\item{quantile_samples}{Samples to use when setting quantiles.}

\item{quantile_group}{Group these features and quantile based on aggregate mean of feature.}

\item{quantile_direction}{Order quantiles in 'descending' or 'ascending' order of values.}

\item{grouping}{If quantiles not set, split data by the specified categorical variable.}
}
\value{
data.table with the results from the various data conditionals applied.
}
\description{
Apply strategies for filtering, ordering, quantiling, and/or grouping of data.
}
\details{
It may be desirable to analyze certain subsets of TSSs or TSRs, or split the data 
based on various categorical variables. This function extends the flexibility of 
various other functions by adding the ability to filter, quantile, order, and/or 
group data prior to downstream analysis.

'filters' gives you the ability to filter TSSs or TSRs based on any column stored
in the data. The filters should be a character in standard R logical statements. 
For example, if you wanted to keep only TSSs from chromosome I with a score greater than
10, the filter would be: "seqnames == 'chrI' & score > 10".

The series of arguments for quantiling allows one to split the data based on the
  quantile of any column with numeric data. 'quantile_by' is the column to use 
  for calculating quantiles, and 'n_quantiles' specifies the number of quantiles 
  to break the data into. Whether the quantiles are calculated in ascending or 
  descending order can be set with 'quantile_direction'. If you want to use only 
  a subset of samples to calculate the quantiles, they can be specified with 'quantile_samples'. 
  Finally, the data can first be split into subgroups before quantiling,
  such as TSR shape class.

The ordering arguments can be used to control the order in which the TSSs or
TSRs are plotted. 'order_by' specifies the numeric column used to generate the order,
and whether the order is ascending or descending is controlled by 'order_direction'.
'order_group' can be used to first split the data based on some categorical value,
such as TSR shape class.

If quantiles are not specified, 'grouping' may be used to split the data based on
a categorical value such as TSR shape class.
}
\examples{
TSSs <- system.file("extdata", "S288C_TSSs.RDS", package="TSRexploreR")
TSSs <- readRDS(TSSs)
exp <- tsr_explorer(TSSs)
exp <- format_counts(exp, data_type="tss")
exp <- tss_clustering(exp)
exp <- tsr_metrics(exp)
conditions <- list(order_by="score", grouping="shape_class")
assembly <- system.file("extdata", "S288C_Assembly.fasta", package="TSRexploreR")
seqs <- tss_sequences(
  exp, genome_assembly=assembly, threshold=10,
  dominant=TRUE, data_conditions=conditions
)
plot_sequence_logo(seqs)

}
